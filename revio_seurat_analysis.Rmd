---
title: "MAS_sequel_analysis"
author: "Anita Ahlert Scoones, Macaulay Group, Earlham Institute"
date: "2025-03-12"
output: html_document
---

# Revio scRNA-seq Data Processing Script

# This script loads Feature Barcode Matrices for two Revio samples, including MAS-seq and Jumpcode data.
# It also loads the final processed Seurat objects for MAS-seq and Jumpcode.

# Expected Folder Structure:
# seurat_data/
# ├── revio/
# │   ├── MASseq/
# │   │   ├── sample1/
# │   │   │   ├── genes_seurat
# │   │   │   ├── isoforms_seurat
# │   │   ├── sample2/
# │   │   │   ├── genes_seurat
# │   │   │   ├── isoforms_seurat
# │   │   ├── revio_MASseq_analysed_sobj.rds  <-- (Final processed Seurat object for MAS-seq)
# │   ├── Jumpcode/
# │   │   ├── sample1/
# │   │   │   ├── genes_seurat
# │   │   │   ├── isoforms_seurat
# │   │   ├── sample2/
# │   │   │   ├── genes_seurat
# │   │   │   ├── isoforms_seurat
# │   │   ├── revio_Jumpcode_analysed_sobj.rds  <-- (Final processed Seurat object for Jumpcode)

# Ensure you have downloaded the dataset and placed it in the `seurat_data/` directory.

```{r Package loading}
#library loading
library(Seurat)
library(ggplot2)
library(cowplot)
library(dplyr)
library(tidyverse)
library(patchwork)
```

```{r 1 Designate data directories}
#Clear out R before starting anything
rm(list=ls())

# Define base directory where "data" is stored
base_dir <- "data/revio"

# Sample 1 Paths
rev_genes_1 <- file.path(base_dir, "MASseq/sample1/genes_seurat")
rev_iso_1 <- file.path(base_dir, "MASseq/sample1/isoforms_seurat")

rev_genes_JC_1 <- file.path(base_dir, "Jumpcode/sample1/genes_seurat")
rev_iso_JC_1 <- file.path(base_dir, "Jumpcode/sample1/isoforms_seurat")

# Sample 2 Paths
rev_genes_2 <- file.path(base_dir, "MASseq/sample2/genes_seurat")
rev_iso_2 <- file.path(base_dir, "MASseq/sample2/isoforms_seurat")

rev_genes_JC_2 <- file.path(base_dir, "Jumpcode/sample2/genes_seurat")
rev_iso_JC_2 <- file.path(base_dir, "Jumpcode/sample2/isoforms_seurat")
```

```{r 2 Import 10X data}
# load data matrices
rev_iso_list <- c(rev_iso_1, rev_iso_2, rev_iso_JC_1, rev_iso_JC_2)
rev_gene_list <- c(rev_genes_1, rev_genes_2, rev_genes_JC_1, rev_genes_JC_2)

rev_gene_X_list <- lapply(rev_gene_list, function(x){Seurat::Read10X(x)})
rev_iso_X_list <- lapply(rev_iso_list, function(x){Seurat::Read10X(x)})
```

```{r 3 Creating seurat objects, adding meta data: MT, sample ID, library type}
rev_seurat_1 <- CreateSeuratObject(rev_gene_X_list[[1]], min.cells = 5)
rev_seurat_1_JC <- CreateSeuratObject(rev_gene_X_list[[3]], min.cells = 5)
rev_seurat_2 <- CreateSeuratObject(rev_gene_X_list[[2]], min.cells = 5)
rev_seurat_2_JC <- CreateSeuratObject(rev_gene_X_list[[4]], min.cells = 5)

rev_seurat_1$barcode <- colnames(rev_seurat_1)
rev_seurat_1_JC$barcode <- colnames(rev_seurat_1_JC)
rev_seurat_2$barcode <- colnames(rev_seurat_2)
rev_seurat_2_JC$barcode <- colnames(rev_seurat_2_JC)

rev_seurat_1[["percent.mt"]] <- PercentageFeatureSet(rev_seurat_1, pattern = "^MT-")
rev_seurat_1_JC[["percent.mt"]] <- PercentageFeatureSet(rev_seurat_1_JC, pattern = "^MT-")
rev_seurat_2[["percent.mt"]] <- PercentageFeatureSet(rev_seurat_2, pattern = "^MT-")
rev_seurat_2_JC[["percent.mt"]] <- PercentageFeatureSet(rev_seurat_2_JC, pattern = "^MT-")

rev_seurat_1$sample <- "sample1"
rev_seurat_1_JC$sample <- "sample1"
rev_seurat_2$sample <- "sample2"
rev_seurat_2_JC$sample <- "sample2"

rev_seurat_1$library_type <- "Revio_MAS"
rev_seurat_1_JC$library_type <- "Revio_MAS_JC"
rev_seurat_2$library_type <- "Revio_MAS"
rev_seurat_2_JC$library_type <- "Revio_MAS_JC"

rev_seurat_1[["iso"]] <- Seurat::CreateAssayObject(counts = rev_iso_X_list[[1]], min.cells=5)
rev_seurat_1_JC[["iso"]] <- Seurat::CreateAssayObject(counts = rev_iso_X_list[[3]], min.cells=5)
rev_seurat_2[["iso"]] <- Seurat::CreateAssayObject(counts = rev_iso_X_list[[2]], min.cells=5)
rev_seurat_2_JC[["iso"]] <-Seurat::CreateAssayObject(counts = rev_iso_X_list[[4]], min.cells=5)

# Function to add suffix based on 'type' column in meta.data
add_suffix_based_on_type <- function(seurat_obj) {
  # Get the 'type' column from meta.data
  type_column <- seurat_obj@meta.data$type
  
  # Check the 'type' column and modify colnames accordingly
 if ("MAS" %in% type_column) {
    colnames(seurat_obj) <- paste0(colnames(seurat_obj), "_MAS")
 } else if ("MAS&JC" %in% type_column) {
  colnames(seurat_obj) <- paste0(colnames(seurat_obj), "_MASandJC")
 }
  
 return(seurat_obj)
}

# Apply the function to your Seurat objects
rev_seurat_1 <- add_suffix_based_on_type(rev_seurat_1)
rev_seurat_1_JC <- add_suffix_based_on_type(rev_seurat_1_JC)
rev_seurat_2 <- add_suffix_based_on_type(rev_seurat_2)
rev_seurat_2_JC <- add_suffix_based_on_type(rev_seurat_2_JC)

rev_seu_list <- c(rev_seurat_1, rev_seurat_1_JC, rev_seurat_2, rev_seurat_2_JC)

#RAW cell Numbers: 1 = 4776, 1_JC = 4784, 2 = 7300, 2_JC = 7164)
```

```{r 4.1 pre-QC stats sample1}
# Sample 1 vs 1_JC

#Genes count Level 
mean(rev_seu_list[[1]]@meta.data$nCount_RNA) #1966.43
range(rev_seu_list[[1]]@meta.data$nCount_RNA) #231 14271

mean(rev_seu_list[[2]]@meta.data$nCount_RNA) #1344.697
range(rev_seu_list[[2]]@meta.data$nCount_RNA) #204 13829

#Iso count Level
mean(rev_seu_list[[1]]@meta.data$nCount_iso) #1883.299
range(rev_seu_list[[1]]@meta.data$nCount_iso) #210 13705

mean(rev_seu_list[[2]]@meta.data$nCount_iso) #1232.921
range(rev_seu_list[[2]]@meta.data$nCount_iso) #160 12810


#Features level
mean(rev_seu_list[[1]]@meta.data$nFeature_RNA) #689.7071 genes
range(rev_seu_list[[1]]@meta.data$nFeature_RNA) #110 3507 

mean(rev_seu_list[[2]]@meta.data$nFeature_RNA) #922.8773 genes
range(rev_seu_list[[2]]@meta.data$nFeature_RNA) #103 4604

#Iso level

mean(rev_seu_list[[1]]@meta.data$nFeature_iso) #728.2493 isoforms
range(rev_seu_list[[1]]@meta.data$nFeature_iso) #103 4604
mean(rev_seu_list[[2]]@meta.data$nFeature_iso) #947.1564 isoforms
range(rev_seu_list[[2]]@meta.data$nFeature_iso) #145 6897
```

```{r 4.2 pre-QC stats sample2}
# Sample 2 vs 2_JC

#Genes count Level 
mean(rev_seu_list[[3]]@meta.data$nCount_RNA) #1455.62
range(rev_seu_list[[3]]@meta.data$nCount_RNA) #151 9756

mean(rev_seu_list[[4]]@meta.data$nCount_RNA) #1327.685
range(rev_seu_list[[4]]@meta.data$nCount_RNA) #159 10691

#Iso count Level
mean(rev_seu_list[[3]]@meta.data$nCount_iso) #1403.554
range(rev_seu_list[[3]]@meta.data$nCount_iso) #137 9459

mean(rev_seu_list[[4]]@meta.data$nCount_iso) #1248.667
range(rev_seu_list[[4]]@meta.data$nCount_iso) #129 10284


#Features level
mean(rev_seu_list[[3]]@meta.data$nFeature_RNA) #594.8564 genes
range(rev_seu_list[[3]]@meta.data$nFeature_RNA) #81 2760 

mean(rev_seu_list[[4]]@meta.data$nFeature_RNA) #910.507 genes
range(rev_seu_list[[4]]@meta.data$nFeature_RNA) #9 4186

#Iso level

mean(rev_seu_list[[3]]@meta.data$nFeature_iso) #637.3798 isoforms
range(rev_seu_list[[3]]@meta.data$nFeature_iso) #73 3500

mean(rev_seu_list[[4]]@meta.data$nFeature_iso) #961.9208 isoforms
range(rev_seu_list[[4]]@meta.data$nFeature_iso) #6 5715
```

```{r 5a Pre-integration merge sobj (visualisation only)}
# merge replicates into one Seurat object (pre-integration)
rev_merged_MAS <- Reduce(merge, c(rev_seurat_1, rev_seurat_2)) #12076 cells

rev_merged_JC <- Reduce(merge, c(rev_seurat_1_JC, rev_seurat_2_JC)) # 11948 cells

rev_merged_MAS
rev_merged_JC
```

```{r 5b Visualising QC metrics pre-QC}
# violin plots for different QC stats
features <- c('nCount_RNA', 'nFeature_RNA', 'nCount_iso', 'nFeature_iso', 'percent.mt')

# make a violin plot for each QC metric
rev_raw_MAS_QC <- lapply(features, function(x){ VlnPlot(
  rev_merged_MAS,
  features = x,
  group.by = 'sample',
  pt.size=0) +
  RotatedAxis() +
  NoLegend() +
  geom_boxplot(notch=TRUE, fill=NA, outlier.shape=NA) +
  xlab('') +
  theme(plot.title = element_text(size=10, hjust=0.5))
})

# make a violin plot for each QC metric
rev_raw_JC_QC <- lapply(features, function(x){ VlnPlot(
  rev_merged_JC,
  features = x,
  group.by = 'sample',
  pt.size=0) +
  RotatedAxis() +
  NoLegend() +
  geom_boxplot(notch=TRUE, fill=NA, outlier.shape=NA) +
  xlab('') +
  theme(plot.title = element_text(size=10, hjust=0.5))
})

# assemble plots with patchwork
wrap_plots(rev_raw_MAS_QC, ncol= 5)
wrap_plots(rev_raw_JC_QC, ncol = 5)
```

```{r 6 Subsetting QC}
#quantiles

# Define a function to calculate lb and ub, and filter the Seurat object
filter_seurat <- function(seurat_obj) {
  lb <- quantile(seurat_obj[["nFeature_RNA"]]$nFeature_RNA, probs = 0.01)
  ub <- quantile(seurat_obj[["nFeature_RNA"]]$nFeature_RNA, probs = 0.99)
  
  subsetted_seurat <- seurat_obj[, seurat_obj[["nFeature_RNA"]] > lb & seurat_obj[["nFeature_RNA"]] < ub & seurat_obj[["percent.mt"]] < 15]
  
  return(subsetted_seurat)
}

# Apply the function to each Seurat object
rev_seurat_1_subset <- filter_seurat(rev_seurat_1) # 4776 > 4408
rev_seurat_1_JC_subset <- filter_seurat(rev_seurat_1_JC) # 4784 > 4685
rev_seurat_2_subset <- filter_seurat(rev_seurat_2) # 7300 > 7122
rev_seurat_2_JC_subset <- filter_seurat(rev_seurat_2_JC) # 7164 > 7019

# merge replicates into one Seurat object(pre-integration)
rev_merged_MAS <- Reduce(merge, c(rev_seurat_1_subset, rev_seurat_2_subset)) #11530

rev_merged_JC <- Reduce(merge, c(rev_seurat_1_JC_subset, rev_seurat_2_JC_subset)) #11704
```

```{r 7 Visualising QC metrics post QC (visualisation only)}
rev_filtered_combined <- Reduce(merge, c(rev_merged_MAS, rev_merged_JC)) #23234

split_by_column <- "library_type"

rev_filtered_plots <- lapply(features, function(feature) {
  VlnPlot(object = rev_filtered_combined,
          features = feature, group.by = split_by_column, 
          cols = viridis(3),
          pt.size = 0)
})

# Modify the plot theme to remove x-axis labels and add legend
plot1 <- rev_filtered_plots[[1]] + theme(axis.text.x = element_blank(),
                   axis.title.x = element_blank()) +
  theme(legend.position="none")
plot2 <- rev_filtered_plots[[2]] + theme(axis.text.x = element_blank(),
                   axis.title.x = element_blank()) +
  theme(legend.position="none")
plot3 <- rev_filtered_plots[[3]] + theme(axis.text.x = element_blank(),
                   axis.title.x = element_blank()) +
  theme(legend.position="none")
plot4 <- rev_filtered_plots[[4]] + theme(axis.text.x = element_blank(),
                   axis.title.x = element_blank()) +
  theme(legend.position="none")

plot5 <- rev_filtered_plots[[5]] + theme(axis.text.x = element_blank(),
                   axis.title.x = element_blank()) +
  guides(fill = guide_legend(title = "Sample"))

plot1 | plot2 | plot3 | plot4 | plot5
```

```{r 8 Gene Level; sobj normalisation, var.feat, scaling, pca}
#pre-processing RNA MAS & JC objs
preprocessSeuratObject <- function(obj, pca_reduction_name = 'pca') {
  obj <- NormalizeData(obj)
  obj <- FindVariableFeatures(obj)
  obj <- ScaleData(obj)
  obj <- RunPCA(obj, reduction.name = pca_reduction_name)
  
  return(obj)
}

rev_merged_MAS <- rev_merged_MAS %>% preprocessSeuratObject()

rev_merged_JC <- rev_merged_JC %>% preprocessSeuratObject()
```

```{r 9 Integrate layers - cca; sample integration (sample 1 and 2) - NOTE: PacBio only}
# After preprocessing, integrate layers, for both MAS and JC
rev_MAS_integrated <- IntegrateLayers(object = rev_merged_MAS, method = CCAIntegration,
  orig.reduction = "pca", new.reduction = "integrated.cca",
  verbose = FALSE)

rev_JC_integrated <- IntegrateLayers(object = rev_merged_JC, method = CCAIntegration,
  orig.reduction = "pca", new.reduction = "integrated.cca",
  verbose = FALSE)
```

```{r 10 Gene Level; Clustering}
# clustering on gene level (for MAS and JC)
DefaultAssay(rev_MAS_integrated) <- 'RNA'
DefaultAssay(rev_JC_integrated) <- 'RNA'

perform_clustering <- function(seurat_obj) {
  # Run UMAP
  seurat_obj <- RunUMAP(seurat_obj, reduction.name = 'umap', reduction = 'integrated.cca', dims = 1:20)
  
  # Find neighbors and clusters on the UMAP space
  seurat_obj <- FindNeighbors(object = seurat_obj, dims = 1:10)
  seurat_obj <- FindClusters(object = seurat_obj, resolution = c(0.5, 0.8, 1))
  
  return(seurat_obj)
}

# Run clustering 
rev_MAS_integrated <- rev_MAS_integrated %>% perform_clustering()

rev_JC_integrated <- rev_JC_integrated %>% perform_clustering()

# Save to RNA cluster col
rev_MAS_integrated$seurat_clusters_RNA <- rev_MAS_integrated$RNA_snn_res.0.8

rev_JC_integrated$seurat_clusters_RNA <- rev_JC_integrated$RNA_snn_res.0.8
```

```{r 11 Plotting clusters & storing RNA lvl clusters}
DefaultAssay(rev_MAS_integrated) <- 'RNA'
DefaultAssay(rev_JC_integrated) <- 'RNA'
DimPlot(rev_MAS_integrated, split.by = "sample")
DimPlot(rev_JC_integrated, split.by = "sample")
```

```{r 12.1 MAS Harmony iso lvl integration}
library(harmony)
library(patchwork)

# switch to the isoform assay 
DefaultAssay(rev_MAS_integrated) <- 'iso'
DefaultAssay(rev_JC_integrated) <- 'iso'

# log normalize data
rev_MAS_integrated <- NormalizeData(rev_MAS_integrated)

# Split the Seurat object by 'Sample' (each sample is a replicate)
split_objects <- SplitObject(rev_MAS_integrated, split.by = "sample")

# Find variable features for each replicate
selected_features <- lapply(split_objects, function(x) {
  FindVariableFeatures(x, nfeatures = 20000) %>% VariableFeatures
})

# Take the intersection of variable features across all samples
VariableFeatures(rev_MAS_integrated) <- Reduce(intersect, selected_features)

# scale data and run PCA
rev_MAS_integrated <- rev_MAS_integrated %>%
  ScaleData() %>%
  RunPCA(reduction.name='pca_iso')

```

```{r 13.1 MAS Iso level integration - Harmony}
# run harmony
rev_MAS_integrated <- RunHarmony(
  rev_MAS_integrated,
  group.by.vars = 'sample',
  reduction='pca_iso',
  assay.use = 'iso',
  reduction.save = 'harmony_iso'
)
```

```{r 14.1 MAS Isoform Level; Clustering}
# run umap
rev_MAS_integrated <- RunUMAP(
  rev_MAS_integrated,
  dims=1:10,
  reduction='harmony_iso',
  reduction.name='umap_iso'
)

# clustering
rev_MAS_integrated <- FindNeighbors(
  rev_MAS_integrated, dims = 1:10,
  reduction='harmony_iso', graph.name = c('iso_sn', 'iso_snn')
)

rev_MAS_integrated <- FindClusters(rev_MAS_integrated, resolution = 0.8, graph.name='iso_snn')

# store iso cluster information

rev_MAS_integrated$seurat_clusters_iso <- rev_MAS_integrated$seurat_clusters

#visualise
DimPlot(rev_MAS_integrated, reduction = "umap", group.by = "sample") | DimPlot(rev_MAS_integrated, reduction = "umap_iso", group.by = "sample") 
```

```{r 12.2 JC iso analysis (same as for MAS data)}
# switch to the isoform assay 
DefaultAssay(rev_JC_integrated) <- 'iso'
DefaultAssay(rev_JC_integrated)

# log normalize data
rev_JC_integrated <- NormalizeData(rev_JC_integrated)

# Split the Seurat object by 'Sample' (each sample is a replicate)
split_objects <- SplitObject(rev_JC_integrated, split.by = "sample")

# Find variable features for each replicate
selected_features <- lapply(split_objects, function(x) {
  FindVariableFeatures(x, nfeatures = 20000) %>% VariableFeatures
})

# Take the intersection of variable features across all samples
VariableFeatures(rev_JC_integrated) <- Reduce(intersect, selected_features)

# scale data and run PCA
rev_JC_integrated <- rev_JC_integrated %>%
  ScaleData() %>%
  RunPCA(reduction.name='pca_iso')
```

```{r 13.2 JC Iso level integration - Harmony}
# run harmony
rev_JC_integrated <- RunHarmony(
  rev_JC_integrated,
  group.by.vars = 'sample',
  reduction='pca_iso',
  assay.use = 'iso',
  reduction.save = 'harmony_iso'
)
```

```{r 14.2 JC Isoform Level; Clustering}
# run umap
rev_JC_integrated <- RunUMAP(
  rev_MAS_integrated,
  dims=1:10,
  reduction='harmony_iso',
  reduction.name='umap_iso'
)

# clustering
rev_JC_integrated <- FindNeighbors(
  rev_JC_integrated, dims = 1:10,
  reduction='harmony_iso', graph.name = c('iso_sn', 'iso_snn')
)

rev_JC_integrated <- FindClusters(rev_JC_integrated, resolution = 0.8, graph.name='iso_snn')

# store iso cluster information

rev_JC_integrated$seurat_clusters_iso <- rev_JC_integrated$seurat_clusters

#visualise
DimPlot(rev_JC_integrated, reduction = "umap", group.by = "sample") | DimPlot(rev_JC_integrated, reduction = "umap_iso", group.by = "sample") 
```

```{r 15.1 RNA+iso WNN multimodal clustering MAS}
# switch back to genes assay
DefaultAssay(rev_MAS_integrated) <- 'RNA'

# run the WNN
rev_MAS_integrated <- FindMultiModalNeighbors(
  rev_MAS_integrated, reduction.list = list("integrated.cca", "harmony_iso"),
  dims.list = list(1:30, 1:30), modality.weight.name = "RNA.weight"
)

   # UMAP and clustering, make sure to use the WNN output!
rev_MAS_integrated <- RunUMAP(
  rev_MAS_integrated,
  nn.name = "weighted.nn",
  reduction.name = "wnn.umap",
  reduction.key = "wnnUMAP_"
)

rev_MAS_integrated <- FindClusters(
  rev_MAS_integrated,
  graph.name = "wsnn",
  algorithm = 3,
  resolution = 0.8,
  verbose = FALSE
)

rev_MAS_integrated$seurat_clusters_wnn <- rev_MAS_integrated$seurat_clusters

# plot clusters from each analysis on the respective UMAPs
p1 <- DimPlot(rev_MAS_integrated, group.by = 'seurat_clusters_RNA', label=TRUE, reduction='umap') +
   NoLegend() + ggtitle('Gene-level clusters')
p2 <- DimPlot(rev_MAS_integrated, group.by = 'seurat_clusters_iso', label=TRUE, reduction='umap_iso') +
   NoLegend() + ggtitle('Isoform-level clusters')
p3 <- DimPlot(rev_MAS_integrated, group.by = 'seurat_clusters_wnn', label=TRUE, reduction='wnn.umap') +
   NoLegend() + ggtitle('Gene + Isoform WNN')

# assemble with patchwork
p1 | p2 | p3

VlnPlot(
  rev_MAS_integrated,
  features = "iso.weight",
  group.by = 'seurat_clusters_iso',
  sort = TRUE,
  pt.size=0) + 
  NoLegend() +
  geom_boxplot(notch=TRUE, fill=NA, outlier.shape=NA) +
  geom_hline(yintercept=0.5, linetype='dashed', color='black') +
  xlab('WNN clusters')

library(ggsankey)

df <- rev_MAS_integrated@meta.data %>% 
  ggsankey::make_long(seurat_clusters_RNA, seurat_clusters_wnn, seurat_clusters_iso)

p <- ggplot(df, aes(x = x, 
               next_x = next_x, 
               node = node, 
               next_node = next_node,
               fill = factor(node),
               label = node)) +
  geom_sankey() +
  geom_sankey_label(size=4) +
  theme_sankey(base_size = 16) + NoLegend() +
  scale_x_discrete(labels=c(
    'seurat_clusters_RNA' = 'Genes',
    'seurat_clusters_wnn' = 'WNN',
    'seurat_clusters_iso' = 'Isoforms'
    )) + ggtitle('Revio MAS-seq')
p

```

```{r 15.2 RNA+iso WNN multimodal clustering JC}
# switch back to genes assay
DefaultAssay(rev_JC_integrated) <- 'RNA'

# run the WNN
rev_JC_integrated <- FindMultiModalNeighbors(
  rev_JC_integrated, reduction.list = list("integrated.cca", "harmony_iso"),
  dims.list = list(1:30, 1:30), modality.weight.name = "RNA.weight"
)

   # UMAP and clustering, make sure to use the WNN output!
rev_JC_integrated <- RunUMAP(
  rev_JC_integrated,
  nn.name = "weighted.nn",
  reduction.name = "wnn.umap",
  reduction.key = "wnnUMAP_"
)

rev_JC_integrated <- FindClusters(
  rev_JC_integrated,
  graph.name = "wsnn",
  algorithm = 3,
  resolution = 0.8,
  verbose = FALSE
)

rev_JC_integrated$seurat_clusters_wnn <- rev_JC_integrated$seurat_clusters

# plot clusters from each analysis on the respective UMAPs
p4 <- DimPlot(rev_JC_integrated, group.by = 'seurat_clusters_RNA', label=TRUE, reduction='umap') +
   NoLegend() + ggtitle('Gene-level clusters')
p5 <- DimPlot(rev_JC_integrated, group.by = 'seurat_clusters_iso', label=TRUE, reduction='umap_iso') +
   NoLegend() + ggtitle('Isoform-level clusters')
p6 <- DimPlot(rev_JC_integrated, group.by = 'seurat_clusters_wnn', label=TRUE, reduction='wnn.umap') +
   NoLegend() + ggtitle('Gene + Isoform WNN')

# assemble with patchwork
p4 | p5 | p6

VlnPlot(
  rev_JC_integrated,
  features = "iso.weight",
  group.by = 'seurat_clusters_iso',
  sort = TRUE,
  pt.size=0) + 
  NoLegend() +
  geom_boxplot(notch=TRUE, fill=NA, outlier.shape=NA) +
  geom_hline(yintercept=0.5, linetype='dashed', color='black') +
  xlab('WNN clusters')

library(ggsankey)

df_jc <- rev_JC_integrated@meta.data %>% 
  ggsankey::make_long(seurat_clusters_RNA, seurat_clusters_wnn, seurat_clusters_iso)

p_jc <- ggplot(df_jc, aes(x = x, 
               next_x = next_x, 
               node = node, 
               next_node = next_node,
               fill = factor(node),
               label = node)) +
  geom_sankey() +
  geom_sankey_label(size=4) +
  theme_sankey(base_size = 16) + NoLegend() +
  scale_x_discrete(labels=c(
    'seurat_clusters_RNA' = 'Genes',
    'seurat_clusters_wnn' = 'WNN',
    'seurat_clusters_iso' = 'Isoforms'
    ))+ ggtitle('Revio MAS-seq with Jumpcode treatment')
p_jc
```

```{r FindMarkers RNA}
DefaultAssay(rev_MAS_integrated) <- 'RNA'
DefaultAssay(rev_JC_integrated) <- 'RNA'

MAS.RNA.markers <- FindAllMarkers(rev_MAS_integrated, only.pos = TRUE)
MAS.RNA.markers %>%
    group_by(cluster) %>%
    dplyr::filter(avg_log2FC > 1)

JC.RNA.markers <- FindAllMarkers(rev_MAS_integrated, only.pos = TRUE)
JC.RNA.markers %>%
    group_by(cluster) %>%
    dplyr::filter(avg_log2FC > 1)
```

```{r 16 Cell type prediction - RNA lvl - MAS & JC - scType https://github.com/IanevskiAleksandr/sc-type}

DefaultAssay(rev_MAS_integrated) <- 'RNA'
DefaultAssay(rev_JC_integrated) <- 'RNA'

library(openxlsx)
lapply(c("dplyr","Seurat","HGNChelper"), library, character.only = T)

# load gene set preparation function
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/gene_sets_prepare.R")
# load cell type annotation function
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/sctype_score_.R")

# DB file
db_ = "https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/ScTypeDB_full.xlsx"; tissue = "Immune system" # e.g. Immune 

tissue <- "Immune system" 

# prepare gene sets
gs_list = gene_sets_prepare(db_, tissue)

# check Seurat object version (scRNA-seq matrix extracted differently in Seurat v4/v5)


seurat_package_v5 <- isFALSE('counts' %in% names(attributes(rev_MAS_integrated[["RNA"]])));
print(sprintf("Seurat object %s is used", ifelse(seurat_package_v5, "v5", "v4")))

# extract scaled scRNA-seq matrix
scRNAseqData_scaled <- if (seurat_package_v5) as.matrix(rev_MAS_integrated[["RNA"]]$scale.data) else as.matrix(rev_MAS_integrated[["RNA"]]@scale.data)

# get cell-type by cell matrix
revio.es.max = sctype_score(scRNAseqData = scRNAseqData_scaled, scaled = TRUE, gs = gs_list$gs_positive, gs2 = gs_list$gs_negative)

# merge by cluster
revio_cL_resutls = do.call("rbind", lapply(unique(rev_MAS_integrated@meta.data$seurat_clusters_RNA), function(cl){
    es.max.cl = sort(rowSums(revio.es.max[ ,rownames(rev_MAS_integrated@meta.data[rev_MAS_integrated@meta.data$seurat_clusters_RNA==cl, ])]), decreasing = !0)
    head(data.frame(cluster = cl, type = names(es.max.cl), scores = es.max.cl, ncells = sum(rev_MAS_integrated@meta.data$seurat_clusters_RNA==cl)), 10)
}))

revio_sctype_scores = revio_cL_resutls %>% group_by(cluster) %>% top_n(n = 1, wt = scores)  

# set low-confident (low ScType score) clusters to "unknown"
revio_sctype_scores$type[as.numeric(as.character(revio_sctype_scores$scores)) < revio_sctype_scores$ncells/4] = "Unknown"
print(revio_sctype_scores[,1:3])

rev_MAS_integrated@meta.data$sctype_RNA_prediction = ""
for(j in unique(revio_sctype_scores$cluster)){
  cl_type = revio_sctype_scores[revio_sctype_scores$cluster==j,]; 
  rev_MAS_integrated@meta.data$sctype_RNA_prediction[rev_MAS_integrated@meta.data$seurat_clusters_RNA == j] = as.character(cl_type$type[1])
}


#------JC


# check Seurat object version (scRNA-seq matrix extracted differently in Seurat v4/v5)
seurat_package_v5 <- isFALSE('counts' %in% names(attributes(rev_JC_integrated[["RNA"]])));
print(sprintf("Seurat object %s is used", ifelse(seurat_package_v5, "v5", "v4")))

# extract scaled scRNA-seq matrix
scRNAseqData_scaled <- if (seurat_package_v5) as.matrix(rev_JC_integrated[["RNA"]]$scale.data) else as.matrix(rev_JC_integrated[["RNA"]]@scale.data)

# get cell-type by cell matrix
revio.es.max = sctype_score(scRNAseqData = scRNAseqData_scaled, scaled = TRUE, gs = gs_list$gs_positive, gs2 = gs_list$gs_negative)

# merge by cluster
revio_cL_resutls = do.call("rbind", lapply(unique(rev_JC_integrated@meta.data$seurat_clusters_RNA), function(cl){
    es.max.cl = sort(rowSums(revio.es.max[ ,rownames(rev_JC_integrated@meta.data[rev_JC_integrated@meta.data$seurat_clusters_RNA==cl, ])]), decreasing = !0)
    head(data.frame(cluster = cl, type = names(es.max.cl), scores = es.max.cl, ncells = sum(rev_JC_integrated@meta.data$seurat_clusters_RNA==cl)), 10)
}))

revio_sctype_scores = revio_cL_resutls %>% group_by(cluster) %>% top_n(n = 1, wt = scores)  

# set low-confident (low ScType score) clusters to "unknown"
revio_sctype_scores$type[as.numeric(as.character(revio_sctype_scores$scores)) < revio_sctype_scores$ncells/4] = "Unknown"
print(revio_sctype_scores[,1:3])

rev_JC_integrated@meta.data$sctype_RNA_prediction = ""
for(j in unique(revio_sctype_scores$cluster)){
  cl_type = revio_sctype_scores[revio_sctype_scores$cluster==j,]; 
  rev_JC_integrated@meta.data$sctype_RNA_prediction[rev_JC_integrated@meta.data$seurat_clusters_RNA == j] = as.character(cl_type$type[1])
}

#plot gene level annotation of MAS & MASwithJC data 
DimPlot(rev_MAS_integrated, label = TRUE, repel = TRUE, group.by = 'sctype_RNA_prediction', reduction = "umap")
DimPlot(rev_JC_integrated, label = TRUE, repel = TRUE, group.by = 'sctype_RNA_prediction', reduction = "umap")  
```

```{r 17 Cell type prediction - ISO lvl - MAS & JC - scType}
DefaultAssay(rev_MAS_integrated) <- 'iso'
DefaultAssay(rev_JC_integrated) <- 'iso'

# check Seurat object version (scRNA-seq matrix extracted differently in Seurat v4/v5)
seurat_package_v5 <- isFALSE('counts' %in% names(attributes(rev_MAS_integrated[["iso"]])));
print(sprintf("Seurat object %s is used", ifelse(seurat_package_v5, "v5", "v4")))

# extract scaled scRNA-seq matrix
scRNAseqData_scaled <- if (seurat_package_v5) as.matrix(rev_MAS_integrated[["iso"]]$scale.data) else as.matrix(rev_MAS_integrated[["iso"]]@scale.data)

# get cell-type by cell matrix
revio.es.max = sctype_score(scRNAseqData = scRNAseqData_scaled, scaled = TRUE, gs = gs_list$gs_positive, gs2 = gs_list$gs_negative)

# merge by cluster
revio_cL_resutls = do.call("rbind", lapply(unique(rev_MAS_integrated@meta.data$seurat_clusters_iso), function(cl){
    es.max.cl = sort(rowSums(revio.es.max[ ,rownames(rev_MAS_integrated@meta.data[rev_MAS_integrated@meta.data$seurat_clusters_iso==cl, ])]), decreasing = !0)
    head(data.frame(cluster = cl, type = names(es.max.cl), scores = es.max.cl, ncells = sum(rev_MAS_integrated@meta.data$seurat_clusters_iso==cl)), 10)
}))

revio_sctype_scores = revio_cL_resutls %>% group_by(cluster) %>% top_n(n = 1, wt = scores)  

# set low-confident (low ScType score) clusters to "unknown"
revio_sctype_scores$type[as.numeric(as.character(revio_sctype_scores$scores)) < revio_sctype_scores$ncells/4] = "Unknown"
print(revio_sctype_scores[,1:3])

rev_MAS_integrated@meta.data$sctype_iso_prediction = ""
for(j in unique(revio_sctype_scores$cluster)){
  cl_type = revio_sctype_scores[revio_sctype_scores$cluster==j,]; 
  rev_MAS_integrated@meta.data$sctype_iso_prediction[rev_MAS_integrated@meta.data$seurat_clusters_iso == j] = as.character(cl_type$type[1])
}

#-----JC

# check Seurat object version (scRNA-seq matrix extracted differently in Seurat v4/v5)
seurat_package_v5 <- isFALSE('counts' %in% names(attributes(rev_JC_integrated[["iso"]])));
print(sprintf("Seurat object %s is used", ifelse(seurat_package_v5, "v5", "v4")))

# extract scaled scRNA-seq matrix
scRNAseqData_scaled <- if (seurat_package_v5) as.matrix(rev_JC_integrated[["iso"]]$scale.data) else as.matrix(rev_JC_integrated[["iso"]]@scale.data)

# get cell-type by cell matrix
revio.es.max = sctype_score(scRNAseqData = scRNAseqData_scaled, scaled = TRUE, gs = gs_list$gs_positive, gs2 = gs_list$gs_negative)

# merge by cluster
revio_cL_resutls = do.call("rbind", lapply(unique(rev_JC_integrated@meta.data$seurat_clusters_iso), function(cl){
    es.max.cl = sort(rowSums(revio.es.max[ ,rownames(rev_JC_integrated@meta.data[rev_JC_integrated@meta.data$seurat_clusters_iso==cl, ])]), decreasing = !0)
    head(data.frame(cluster = cl, type = names(es.max.cl), scores = es.max.cl, ncells = sum(rev_JC_integrated@meta.data$seurat_clusters_iso==cl)), 10)
}))

revio_sctype_scores = revio_cL_resutls %>% group_by(cluster) %>% top_n(n = 1, wt = scores)  

# set low-confident (low ScType score) clusters to "unknown"
revio_sctype_scores$type[as.numeric(as.character(revio_sctype_scores$scores)) < revio_sctype_scores$ncells/4] = "Unknown"
print(revio_sctype_scores[,1:3])

rev_JC_integrated@meta.data$sctype_iso_prediction = ""
for(j in unique(revio_sctype_scores$cluster)){
  cl_type = revio_sctype_scores[revio_sctype_scores$cluster==j,]; 
  rev_JC_integrated@meta.data$sctype_iso_prediction[rev_JC_integrated@meta.data$seurat_clusters_iso == j] = as.character(cl_type$type[1])
}

DimPlot(rev_MAS_integrated, label = TRUE, repel = TRUE, group.by = 'sctype_iso_prediction', reduction = "umap_iso")
DimPlot(rev_JC_integrated, label = TRUE, repel = TRUE, group.by = 'sctype_iso_prediction', reduction = "umap_iso")
```

```{r 18 Cell type prediction - ISO lvl - MAS & JC - SingleR}
library(SingleR)
library(celldex)
library(tidyverse)
library(pheatmap)

# 0. Set up reference data -----------
ref <- celldex::HumanPrimaryCellAtlasData()
View(as.data.frame(colData(ref)))

#----- MAS 

# 1. Check iso is default assay
DefaultAssay(rev_MAS_integrated)

# 2. Extract normalized data layer
revio_MAS_iso_counts <- LayerData(rev_MAS_integrated, assay = "iso", layer = 'data')

# 3. Run singleR (takes a while)
pred_MAS_iso <- SingleR(test = revio_MAS_iso_counts,
        ref = ref,
        labels = ref$label.fine)

head(pred_MAS_iso)

# 4. Save to meta
rev_MAS_integrated$iso_singleR.labels <- pred_MAS_iso$labels[match(rownames(rev_MAS_integrated@meta.data), rownames(pred_MAS_iso))]

pred_MAS_iso
pred_MAS_iso$scores

plotScoreHeatmap(pred_MAS_iso)

# ...Based on deltas across cells ----------

plotDeltaDistribution(pred_MAS_iso)

tab_MAS_iso <- table(Assigned=pred_MAS_iso$labels, Clusters=rev_MAS_integrated$seurat_clusters_iso)

pheatmap(log10(tab_MAS_iso+10), color = colorRampPalette(c('white','blue'))(10))

#------JC 

# 1. Check iso is default assay
DefaultAssay(rev_JC_integrated)

# 2. Extract normalized data layer
revio_JC_iso_counts <- LayerData(rev_JC_integrated, assay = "iso", layer = 'data')

# 3. Run singleR  (takes a while)
pred_JC_iso <- SingleR(test = revio_JC_iso_counts,
        ref = ref,
        labels = ref$label.fine)

head(pred_JC_iso)

# 4. Save to meta
rev_JC_integrated$iso_singleR.labels <- pred_JC_iso$labels[match(rownames(rev_JC_integrated@meta.data), rownames(pred_JC_iso))]

pred_JC_iso
pred_JC_iso$scores

plotScoreHeatmap(pred_JC_iso)

# ...Based on deltas across cells ----------

plotDeltaDistribution(pred_JC_iso)

tab_JC_iso <- table(Assigned=pred_JC_iso$labels, Clusters=rev_JC_integrated$seurat_clusters_iso)

pheatmap(log10(tab_JC_iso+10), color = colorRampPalette(c('white','blue'))(10))

DimPlot(rev_MAS_integrated, label = TRUE, repel = TRUE, group.by = 'iso_singleR.labels', reduction = "umap_iso")
DimPlot(rev_JC_integrated, label = TRUE, repel = TRUE, group.by = 'iso_singleR.labels', reduction = "umap_iso")
```

```{r 19 Assigning final cell type annotations to cells based on markers and predictions - MAS & JC}
# adding final publication annotations for seurat obj - levels 0-17
manual_rev_MAS_idents <- c("Naive_Tcells:CD4+", 
                       "Naive_Tcells:CD8+",
                       "Monocytes:CD14+", 
                       "Tcells:CD4+", 
                       "CD8+_NKT-like_cells",
                       "Tcells_reg:CD4+", 
                       "Tcells:CD8+", 
                       "B cells", 
                       "γδ-T cells", 
                       "B cells",
                       "Monocytes:CD14+",
                       "NK cells", 
                       "Macrophages",
                       "DCs",
                       "Macrophages",
                       "Platelets",
                       "Plasmacytoid DCs",
                       "Monocyte:CD16+")

manual_rev_JC_idents <- c("Naive_Tcells:CD4+", 
                       "Naive_Tcells:CD8+",
                       "Monocytes:CD14+", 
                       "Tcells:CD4+",
                       "CD8+_NKT-like_cells",
                       "Tcells_reg:CD4+", 
                       "Tcells:CD8+", 
                       "NK cells",
                       "Pre-B cells", 
                       "Naive-B cells", 
                       "γδ-T cells",
                       "Monocytes:CD16+",
                       "Monocytes:CD14+",
                       "Macrophages",
                       "DCs",
                       "Macrophages",
                       "Platelets",
                       "Plasmacytoid DCs")


names(manual_rev_MAS_idents) <- levels(rev_MAS_integrated)
names(manual_rev_JC_idents) <- levels(rev_JC_integrated)

rev_MAS_integrated <- RenameIdents(rev_MAS_integrated, manual_rev_MAS_idents)
rev_JC_integrated <- RenameIdents(rev_JC_integrated, manual_rev_JC_idents)

DimPlot(rev_MAS_integrated, label = TRUE, pt.size = 1, reduction = "umap") + NoLegend()
DimPlot(rev_JC_integrated, label = TRUE, pt.size = 1, reduction = "umap") + NoLegend()

rev_MAS_integrated@meta.data$manual_annotation <- Idents(rev_MAS_integrated)
rev_JC_integrated@meta.data$manual_annotation <- Idents(rev_JC_integrated)

MAS_meta <- rev_MAS_integrated@meta.data
JC_meta <- rev_JC_integrated@meta.data
```

```{r 20 Adding illumina cell type annots to sobj@meta}
# This step integrates the cell type annotations stored in @meta.data from the Illumina scRNAseq object (same sample). Cell barcodes common to both objects are identified, and cell type labels from the Illumina object are added to the sequel@meta.data under $illumina_annotation.

# To do this, you must first load the Illumina Seurat object. Ensure that the file `illumina_analysed_sobj.rds` is located in the `data/illumina/` directory.

# 1 Load Illumina Seurat object
illumina <- readRDS("data/illumina/illumina_analysed_sobj.rds") 
illumina_meta <- illumina@meta.data

# 2 Extract meta data 
revio_mas_meta <- rev_MAS_integrated@meta.data

# NOTE: you may need to use reverse complement barcode sequence for this step to identify matching cells across datasets
# to get rev comp barcode sequence:
# 3.1 clean MAS BCs 
revio_mas_meta$rev_comp_bc <- revio_mas_meta$barcode %>% gsub("-.*", "", .)

# 3.2 reverse comp
library(dplyr)
library(Biostrings)

reverse_complement <- function(barcodes) {
    as.character(reverseComplement(DNAStringSet(barcodes)))
}

revio_mas_meta$rev_comp_bc <- reverse_complement(revio_mas_meta$rev_comp_bc)

# 4 Check intersect 
common_barcodes_MAS_illumina <- intersect(revio_mas_meta$rev_comp_bc, illumina_meta$barcode)

length(common_barcodes_MAS_illumina)  # returns the number of matching barcodes = 4387

# 5 add illumina cell type annotations to revio meta data using matching bcs
revio_mas_meta <- revio_mas_meta %>%
  left_join(
    illumina_meta %>% select(barcode, cell_types),  # Use barcode and cell_types
    by = c("rev_comp_bc" = "barcode")             # Match rev_comp_bc in revio to barcode in illumina_meta
  )

# 6 Rename the column for clarity
colnames(revio_mas_meta)[which(colnames(revio_mas_meta) == "cell_types")] <- "illumina_annotation"

# 7 Update metadata

MAS_rownames <- colnames(rev_MAS_integrated) # important
rownames(revio_mas_meta) <- MAS_rownames
rev_MAS_integrated@meta.data <- revio_mas_meta

#--------- JC

# 2 Extract meta data 
revio_JC_meta <- rev_JC_integrated@meta.data

# NOTE: you may need to use reverse complement barcode sequence for this step to identify matching cells across datasets. if intersect(revio_JC_meta$rev_comp_bc, illumina_meta$barcode) = character(0) perform step 3 before proceeding. 

# 3.1 clean JC BCs 
revio_JC_meta$rev_comp_bc <- revio_JC_meta$barcode %>% gsub("-.*", "", .)

# 3.2 reverse comp
library(dplyr)
library(Biostrings)

reverse_complement <- function(barcodes) {
    as.character(reverseComplement(DNAStringSet(barcodes)))
}

revio_JC_meta$rev_comp_bc <- reverse_complement(revio_JC_meta$rev_comp_bc)

# 4 Check intersect (barcodes found in both datasets)
common_barcodes_JC_illumina <- intersect(revio_JC_meta$rev_comp_bc, illumina_meta$barcode)

length(common_barcodes_JC_illumina)  # returns the number of matching barcodes = 4387

# 5 Add illumina cell type annotations to revio meta data using matching bcs
revio_JC_meta <- revio_JC_meta %>%
  left_join(
    illumina_meta %>% select(barcode, cell_types),  # Use barcode and cell_types
    by = c("rev_comp_bc" = "barcode")             # Match rev_comp_bc in revio to barcode in illumina_meta
  )

# 6 Rename the column for clarity
colnames(revio_JC_meta)[which(colnames(revio_JC_meta) == "cell_types")] <- "illumina_annotation"

# 7 Update metadata

JC_rownames <- colnames(rev_JC_integrated) # important
rownames(revio_JC_meta) <- JC_rownames
rev_JC_integrated@meta.data <- revio_JC_meta
```

```{r 21.1 Adding TRUST4 results to sobj@meta MAS}
# Input files needed:
# These files contain barcode information for different immune cell types (B cells, αβ T cells, γδ T cells) as reconstructed by TRUST4 from Revio sequencing data.
# They should be located within the `Ig_reconstruction_TRUST4/revio_#MASorJC_TRUST4/` directory.

# Define the directory path 
trust4_dir <- "~/Ig_reconstruction_TRUST4/revio_MAS_TRUST4/"

#abT
revio_MAS_abT <- read.delim(file.path(trust4_dir, "sample1_revio_MAS_defaultsettings_abTbarcodes.txt", col.names = "barcode"))

revio_MAS_abT_2 <-read.delim(read.delim(file.path(trust4_dir, "sample2_revio_MAS_defaultsettings_abTbarcodes.txt", col.names = "barcode"))

revio_MAS_abT <- rbind(revio_MAS_abT, revio_MAS_abT_2)

#B
revio_MAS_B <- read.delim(read.delim(file.path(trust4_dir, "sample1_revio_MAS_defaultsettings_Bbarcodes.txt", col.names = "barcode"))

revio_MAS_B_2 <- read.delim(read.delim(file.path(trust4_dir, "sample2_revio_MAS_defaultsettings_Bbarcodes.txt", col.names = "barcode"))

revio_MAS_B <- rbind(revio_MAS_B, revio_MAS_B_2)


#gdT
revio_MAS_gdT <- read.delim(read.delim(file.path(trust4_dir, "sample1_revio_MAS_defaultsettings_gdTbarcodes.txt", col.names = "barcode"))

revio_MAS_gdT_2 <- read.delim(read.delim(file.path(trust4_dir, "sample2_revio_MAS_defaultsettings_gdTbarcodes.txt", col.names = "barcode"))


# Get meta data and initialize for trust4 input
revio_mas_meta <- rev_MAS_integrated@meta.data
revio_mas_meta$TRUST4 <- NA  # Ensure TRUST4 is initialized with NA

# Clean BCs to identify matches
MAS_rownames <- rownames(revio_mas_meta)
clean_MAS_rownames <- MAS_rownames %>% gsub("-.*", "", .)

# Get the matching row indices
matching_revio_abT_indices <- which(clean_MAS_rownames %in% revio_abT$barcode)
matching_revio_B_indices <- which(clean_MAS_rownames %in% revio_B$barcode)
matching_revio_gdT_indices <- which(clean_MAS_rownames %in% revio_gdT$barcode)

# Update TRUST4 column where there's a match
revio_mas_meta$TRUST4[matching_revio_abT_indices] <- "TCRab"
revio_mas_meta$TRUST4[matching_revio_B_indices] <- "B"
revio_mas_meta$TRUST4[matching_revio_gdT_indices] <- "TCRgd"

# Re-assign to sobj meta
rev_MAS_integrated@meta.data <- revio_mas_meta
DimPlot(rev_MAS_integrated, label = TRUE, pt.size = 1, reduction = "umap", group.by = "TRUST4", order = T) + NoLegend()
```

```{r 21.3 Adding TRUST4 results to sobj@meta JC}

trust4_dir <- "~/Ig_reconstruction_TRUST4/revio_JC_TRUST4/"

#abT
revio_JC_abT <- read.delim(file.path(trust4_dir, "sample1_revio_JC_defaultsettings_abTbarcodes.txt", col.names = "barcode"))

revio_JC_abT_2 <-read.delim(read.delim(file.path(trust4_dir, "sample2_revio_JC_defaultsettings_abTbarcodes.txt", col.names = "barcode"))

revio_JC_abT <- rbind(revio_JC_abT, revio_JC_abT_2)

#B
revio_JC_B <- read.delim(read.delim(file.path(trust4_dir, "sample1_revio_JC_defaultsettings_Bbarcodes.txt", col.names = "barcode"))

revio_JC_B_2 <- read.delim(read.delim(file.path(trust4_dir, "sample2_revio_JC_defaultsettings_Bbarcodes.txt", col.names = "barcode"))

revio_JC_B <- rbind(revio_JC_B, revio_JC_B_2)

#gdT
revio_JC_gdT <- read.delim(read.delim(file.path(trust4_dir, "sample1_revio_JC_defaultsettings_gdTbarcodes.txt", col.names = "barcode"))

revio_JC_gdT_2 <- read.delim(read.delim(file.path(trust4_dir, "sample2_revio_JC_defaultsettings_gdTbarcodes.txt", col.names = "barcode"))

revio_JC_gdT <- rbind(revio_JC_gdT, revio_JC_gdT_2)

# Get meta data and initialize for trust4 input
revio_JC_meta <- rev_JC_integrated@meta.data
revio_JC_meta$TRUST4 <- NA  # Ensure TRUST4 is initialized with NA

# Clean BCs to identify matches
JC_rownames <- rownames(JC_meta)
clean_JC_rownames <- JC_rownames %>% gsub("-.*", "", .)

# Get the matching row indices
matching_JC_abT_indices <- which(clean_JC_rownames %in% revio_JC_abT$barcode)
matching_JC_B_indices <- which(clean_JC_rownames %in% revio_JC_B$barcode)
matching_JC_gdT_indices <- which(clean_JC_rownames %in% revio_JC_gdT$barcode)

# Update TRUST4 column where there's a match
JC_meta$TRUST4[matching_JC_abT_indices] <- "TCRab"
JC_meta$TRUST4[matching_JC_B_indices] <- "B"
JC_meta$TRUST4[matching_JC_gdT_indices] <- "TCRgd"

# Re-assign to sobj meta
revio_JC_sobj@meta.data <- JC_meta
DimPlot(revio_JC_sobj, label = TRUE, pt.size = 1, reduction = "umap", group.by = "TRUST4", order = T) + NoLegend()
```




